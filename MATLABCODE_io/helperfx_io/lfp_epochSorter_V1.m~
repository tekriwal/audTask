%AT created 3/26/20; goal is to have fx that parses out the relevant epochs
%based on however the inputs were sorted


function [struct] = lfp_epochSorter_V1(struct, trial_inds, trial_start_times, taskbase_io, align_event1_times, align_event2_times, Ephys_struct, LFPSamplerate, LFP_file)




    
    struct.trialStart_times = (taskbase_io.trialStart_AO(trial_inds)')/(Ephys_struct.mer.sampFreqHz);
    struct.upPressed_times = taskbase_io.events.upPressed(trial_inds)';
    struct. stimDelivered_times = taskbase_io.events.stimDelivered(trial_inds)';
    struct. goCue_times = taskbase_io.events.goCue(trial_inds)';
    struct.leftUP_times = taskbase_io.events.leftUP(trial_inds)';
    struct.submitsResponse_times = taskbase_io.events.submitsResponse(trial_inds)';
    struct.feedback_times = taskbase_io.events.feedback(trial_inds)';
    
    
    struct.ref_spike_times = [];
    struct.trial_inds = [];
    
    event_times1 = struct.(align_event1_times);
    event_times2 = struct.(align_event2_times);
    
    for trial_num = 1:length(trial_start_times)
        
        
        ref_time_start = trial_start_times(trial_num) + event_times1(trial_num); % absolute time of event to reference spikes to
        ref_time_end = trial_start_times(trial_num) + event_times2(trial_num); % absolute time of event to reference spikes to
        
        if ~isnan(ref_time_start) % ref_time will be NaN if the particular event did not occur in this trial
            
            trial_LFP_times = LFP_file(round(ref_time_start*LFPSamplerate):round(ref_time_end*LFPSamplerate));
            
            struct.ref_spike_times = [struct.ref_spike_times; trial_LFP_times(:)];
            struct.trial_inds = [struct.trial_inds; (ones(length(trial_LFP_times), 1) * trial_num)];
            
            %AT PICK UP WITH BELOW FX!
            [struct] = lfp_bandpowers_V1(signal, Fs);

            
        end
        
    end
    






end